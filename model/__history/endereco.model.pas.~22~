unit endereco.model;

interface

uses System.SysUtils, System.JSON, System.Variants, XMLDoc, XMLIntF, FireDAC.Comp.Client, FireDAC.Stan.Param;

type
  TEndereco = class

  private
    FCodigo: Integer;
    FCep: string;
    FLogradouro: string;
    FComplemento: string;
    FBairro: string;
    FLocalidade: string;
    FUF: string;

  public
    procedure Pesquisar(TblCep: TFDQuery; sPesquisa, sCampo: string);
    procedure Carregar(QryCep: TFDQuery; FEndereco: TEndereco; iCodigo: Integer);
    function Inserir(QryCep: TFDQuery; FEndereco: TEndereco; out sErro: string): Boolean;
    function Alterar(QryCep: TFDQuery; FEndereco: TEndereco; iCodigo: Integer; out sErro: string): Boolean;
    function Excluir(QryCep: TFDQuery; iCodigo: Integer; out sErro : string): Boolean;
    procedure CarregarJSON(const JSONString: string);
    procedure CarregarXML(const AXMLString: string);
    function CEPExistente(QryTemp: TFDQuery; CEP: string): Boolean;
    function GetXMLValueOrDefault(Node: IXMLNode; const TagName: string; const DefaultValue: string = ''): string;
    procedure PersistirDados;


    property Codigo: Integer read FCodigo write FCodigo;
    property Cep: string read FCep write FCep;
    property Logradouro: string read FLogradouro write FLogradouro;
    property Complemento: string read FComplemento write FComplemento;
    property Bairro: string read FBairro write FBairro;
    property Localidade: string read FLocalidade write FLocalidade;
    property UF: string read FUF write FUF;

  end;

implementation

uses Vcl.Dialogs;

{ TEndereco }

procedure TEndereco.Pesquisar(TblCep: TFDQuery; sPesquisa, sCampo: string);
begin
  with TblCep do
  begin
    Close;
    SQL.Clear;
    SQL.Add('select cep.codigo, ');
    SQL.Add('cep.cep, ');
    SQL.Add('cep.logradouro, ');
    SQL.Add('cep.complemento, ');
    SQL.Add('cep.bairro, ');
    SQL.Add('cep.localidade, ');
    SQL.Add('cep.uf ');
    SQL.Add('from tab_cep cep');
    SQL.Add('where ' + sCampo + ' like :pNOME');
    SQL.Add('order by ' + sCampo);
    ParamByName('PNOME').AsString := sPesquisa;
    Open();
  end;
end;

procedure TEndereco.Carregar(QryCep: TFDQuery; FEndereco: TEndereco; iCodigo: Integer);
begin
  with QryCep do
  begin
    SQL.Clear;
    SQL.Add('select cep.codigo, ');
    SQL.Add('cep.cep, ');
    SQL.Add('cep.logradouro, ');
    SQL.Add('cep.complemento, ');
    SQL.Add('cep.bairro, ');
    SQL.Add('cep.localidade, ');
    SQL.Add('cep.uf ');
    SQL.Add('from tab_cep cep');
    SQL.Add('where codigo = :codigo');
    ParamByName('codigo').AsInteger := iCodigo;
    Open;

    with FEndereco, QryCep do
    begin
      Cep := FieldByName('CEP').AsString;
      Logradouro := FieldByName('LOGRADOURO').AsString;
      Complemento := FieldByName('COMPLEMENTO').AsString;
      Bairro := FieldByName('BAIRRO').AsString;
      Localidade := FieldByName('LOCALIDADE').AsString;
      UF := FieldByName('UF').AsString;
    end;
  end;
end;

function TEndereco.Inserir(QryCep: TFDQuery; FEndereco: TEndereco; out sErro: string): Boolean;
begin
  Result := True;
end;

function TEndereco.Alterar(QryCep: TFDQuery; FEndereco: TEndereco; iCodigo: Integer; out sErro: string): Boolean;
begin
  Result := False;
end;

function TEndereco.Excluir(QryCep: TFDQuery; iCodigo: Integer; out sErro: string): Boolean;
begin
  Result := False;
end;

procedure TEndereco.CarregarJSON(const JSONString: string);
var
  JSONValue: TJSONValue;
  JSONArray: TJSONArray;
  JSONObj: TJSONObject;
  i: Integer;
begin
  // Primeiro, tentamos parsear como um objeto
  JSONValue := TJSONObject.ParseJSONValue(JSONString);

  if Assigned(JSONValue) and (JSONValue is TJSONObject) then
  begin
    // Se for um objeto, carrega os dados
    JSONObj := JSONValue as TJSONObject;
    Cep := JSONObj.GetValue<string>('cep');
    Logradouro := JSONObj.GetValue<string>('logradouro');
    Complemento := JSONObj.GetValue<string>('complemento');
    Bairro := JSONObj.GetValue<string>('bairro');
    Localidade := JSONObj.GetValue<string>('localidade');
    UF := JSONObj.GetValue<string>('uf');
  end
  else
  begin
    // Se não for objeto, tenta parsear como array
    JSONArray := TJSONArray(TJSONObject.ParseJSONValue(JSONString));
    if Assigned(JSONArray) then
    begin
      // Se houver apenas um item, carrega os dados
      if JSONArray.Count = 1 then
      begin
        JSONObj := JSONArray.Items[0] as TJSONObject;
        Cep := JSONObj.GetValue<string>('cep');
        Logradouro := JSONObj.GetValue<string>('logradouro');
        Complemento := JSONObj.GetValue<string>('complemento');
        Bairro := JSONObj.GetValue<string>('bairro');
        Localidade := JSONObj.GetValue<string>('localidade');
        UF := JSONObj.GetValue<string>('uf');
      end
      else if JSONArray.Count > 1 then
      begin
        // Se houver mais de um item, você pode decidir o que fazer
        for i := 0 to JSONArray.Count - 1 do
        begin
          JSONObj := JSONArray.Items[i] as TJSONObject;
          // Armazenar ou processar cada registro do array como necessário
        end;

        // Aqui você pode abrir o formulário para seleção, por exemplo
      end;
    end
    else
      raise Exception.Create('Erro: O objeto retornado não é um JSON válido.');
  end;

  // Libera JSONValue após uso
  JSONValue.Free;
end;

procedure TEndereco.CarregarXML(const AXMLString: string);
var XMLDoc: IXMLDocument;
    RootNode: IXMLNode;
begin
  XMLDoc := LoadXMLData(AXMLString);
  RootNode := XMLDoc.DocumentElement;
  if Assigned(RootNode) then
  begin
    Cep := GetXMLValueOrDefault(RootNode, 'cep');
    Logradouro := GetXMLValueOrDefault(RootNode, 'logradouro');
    Complemento := GetXMLValueOrDefault(RootNode, 'complemento');
    Bairro := GetXMLValueOrDefault(RootNode, 'bairro');
    Localidade := GetXMLValueOrDefault(RootNode, 'localidade');
    UF := GetXMLValueOrDefault(RootNode, 'uf');
  end
  else
    raise Exception.Create('Erro ao carregar o XML');
end;

function TEndereco.CEPExistente(QryTemp: TFDQuery; CEP: string): Boolean;
begin
  Result := False;
  with QryTemp do
  begin
    SQL.Clear;
    SQL.Add('select * from tab_cep where cep = :cep');
    ParamByName('CEP').AsString := CEP;
    Open();
    if not Eof then
      Result := True;
  end;
end;

procedure TEndereco.PersistirDados;
begin
//
end;

function TEndereco.GetXMLValueOrDefault(Node: IXMLNode; const TagName, DefaultValue: string): string;
begin
  if not VarIsNull(Node.ChildValues[TagName]) then
    Result := Node.ChildValues[TagName]
  else
    Result := DefaultValue;

end;

end.
